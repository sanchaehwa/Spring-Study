자바에서 List, Map 은 컬렉션 프레임워크의 일부이다

컬렉션 프레임워크 : 자바에서 데이터를 효율적으로 저장하고 관리할수 있도록 제공하는 자료구조 및 알고리즘

컬렉션 프레임워크 : List Set Map 

- List는 순서가 보장되고 중복이 허용됨. 인덱스로 요소 접근 (ArrayList 는 조회할때 유용, LinkedList 는 추가 삭제 성능이 뛰어남)
- Set은 순서가 보장되지않고 중복이 허용되지않음. 특정값을 찾는데 용이함
- Map은 Key값과 Value 값으로 데이터를 저장함. Key는 중복되지않는 고유한값. Value 는 중복될 수있음.
- 컬렉션 프레임워크는 제너릭이 지원되어 타입을 지정하여 타입 안정성 확보

---

### 전략패턴

스프링에서 List, Map을 활용하여 동일한 타입내 모든 스프링 빈을 조회할 수 있다.

전략 패턴: 할인 서비스를 제공한다 (개발자가 고정할인과 할인금액이 등급에 따라 변경되는 방법을 선택할 수 있는 경우)

그렇다면 고정할인의 객체 (빈)을 조회해서 고정할인때만 사용하게 선택할 수 있게, 할인금액의 객체(빈)을 조회해서 비율 할인 정책만 사용하게 선택할 수 있게

if -else 문으로 언제는 고정할인 , 언제는 비율 할인 정책 이렇게 하지않고 동적으로 변경 가능하고 확장성이 있는 설계를 하기 위해 전략 패턴을 사용하는것, 

@Component 또는 @Bean으로 각 전략을 **빈으로 관리**하여 **Spring의 DI(의존성 주입)** 활용 가능

---

### 데이터 베이스 커낵션 풀

1. DB connection 이란

애플리케이션 과 데이터 베이스가 서버에 통신 할 수 있도록 하는 기능

+JDBC Driver 

- Java가 다양한 데이터 베이스를 지원할 수 있는 이유는 각 데이터 베이스에 맞는 JDBC 드라이버가 구현되어 있기 때문
- JDBC Driver는 Java 애플리케이션과 각 DB 간의 통신을 중개하여 동일한 JDBC API를 사용하여도 각 DB에 적합한 프로토콜로 요청을 전달하고 응답받을수있음.
- JDBC API란 Connection (데이터베이스에 연결하고 사용이 끝나면 닫는 역할) Statement (SQL 쿼리 실행하는 객체 ) 
return getConnection (SQL DB에 사용하면 SQL DB에 적합한 프로토콜로 요청이 전달하고 응답 받을 수 있겠지)
- 근데 Connection 객체를 각 DB를 연결할때마다 사용하면 좋지 않음 (네트워크 비용에서도 리소스 사용에서도 , 비용적 측면에서도)
- 그래서 연결할때마다 Connection 객체를 사용하는 것이 아니라, DB ConnectionPoo을 사용하는것!
- DB Connection Pool은 데이터 베이스로의 추가 요청이 필요할때 연결을 재사용 할 수 있도록 관리되는 데이터 베이스 연결 캐시


```java
public Connection getConnection() {
				try {
						return DriverManager.getConnection("jdbc: mysql :// + SERVER + "/" + DATABASE + OPTION, USERNAME , PASSWORD); //DB 드라이버 로드 - 연결
					} catch (final SQLException e) {
						System.err.println("DB 연결 오류 " + e.getMessage());
						e.printStackTrace();
						return null;
				}
			}
```

---

### 빈 생명주기

빈 생명주기 관리 → Spring DI 컨테이너 

객체 생성 / 객체가 필요하면 이 객체가 필요한게 있으면 외부에서 끌어다 사용 

그럼 스프링 컨테이너 생성 → 빈을 생성하거나 등록 → 의존성 주입 과 동시에 초기화 → 서비스 종료 컨테이너 종료하면 객체를 소멸 

스프링 컨테이너 생성 -> Bean 생성 -> 의존성 주입 -> **초기화 콜백** -> Bean 사용 -> **소멸 전 콜백** -> 스프링 종료

---

### 컨테이너 종류

ApplicationContext : 기본적인 스프링 컨테이너, 빈관리 의존성 주입, 이벤트 처리, 메시지 소스 처리 -Context를 직접 종료하거나 새로고침할 수는 없다. 

ConfigurableApplicationContext : ApplicationContext를 확장한거고, Context를 종료하거나 새로고침할 수 있다.

직접 라이프사이클를 관리하고 싶으면 ConfigurableApplicationContext를 쓸거고

**컨텍스트(Context)는 빈(Bean)을 관리하는 컨테이너**이고,

컨텍스트가 생성되면 빈들도 함께 생성되고,

컨텍스트가 종료되면 빈들도 같이 사라짐

**📌 ApplicationContext**

ApplicationContext가 자동으로 해주는 것:

•	**빈(Bean) 등록** → @Component, @Bean으로 선언한 객체를 자동으로 빈으로 만들어줌.

•	**의존성 주입(DI)** → @Autowired 등을 이용해서 필요한 빈을 자동으로 넣어줌.

•	**빈의 라이프사이클 관리** → 빈 생성, 초기화, 소멸을 자동으로 처리.

•	**이벤트 처리 및 리소스 로딩** → 메시지 소스, 환경 설정 값 등을 관리.

---

### 스프링 빈 초기화

스프링 빈의 이벤트 라이프 사이클

컨테이너 생성 → ←—-스프링 빈 생성 (컨테이너 등록) → 의존관계가 주입 —→ //초기화 콜백 ——> 빈 사용 —→ 빈 소멸 — 소멸전 콜백 —> 스프링 종료 

**💡객체를 생성하는 과정과 초기화 하는 과정의 분리**

```java
public class NetworkClient {
    private String url;

    // 생성자에서 네트워크 연결까지 수행 (잘못된 방식)
    public NetworkClient(String url) {
    //객체 생성
        this.url = url;
        System.out.println("생성자 호출: url = " + url);

        // 생성자에서 무거운 초기화 작업 수행 (비효율적)
        connect();
        call("초기화 연결 메시지");
    }

    public void connect() {
        System.out.println("connect = " + url);
    }

    public void call(String message) {
        System.out.println("call: url = " + url + " message = " + message);
    }

    public void disconnect() {
        System.out.println("disconnect: " + url);
    }
}
```

객체를 생성하고 connect 초기화 작업을 하고 있으니깐, 객체를 생성하고 url를 변경 못함 하려면 새로운 객체를 만들어야하고. 테스트에도 어렵다 그래서 객체 생성과 초기화는 분리

**스프링은** **크게** 3**가지** **방법으로** **빈** **생명주기** **콜백을** **지원한다**

인터페이스(InitializingBean, DisposableBean) : InitializingBean 초기화 Disposable 소멸전

설정 정보에 초기화 메서드, 종료 메서드 지정

@PostConstruct, @PreDestroy 애노테이션 지원

---

### 스프링 빈 스코프

**1. 스프링 빈은 기본적으로 싱글톤으로 관리됨**

**싱글톤 패턴**: 하나의 객체만 생성해서 애플리케이션 내에서 여러 번 재사용하는 디자인 패턴

**스프링의 싱글톤**:

• 스프링 컨테이너가 애플리케이션 시작 시 **한 번만 객체(빈)를 생성**

• 필요할 때마다 **같은 인스턴스를 재사용** (빈 공유)

• 컨테이너가 종료될 때까지 빈이 유지됨

**2. 스코프(Bean Scope)란?**

• 객체(빈)가 **생성되고 존재하는 범위**를 의미

• **항상 싱글톤일 필요는 없음**, 즉 하나의 인스턴스를 모든 곳에서 공유하지 않아도 됨

• 스코프를 사용하면 **필요할 때마다 새로운 인스턴스를 생성할 수도 있음**

**3. 주요 스코프 종류와 특징**

•**싱글톤(singleton)**: 모든 곳에서 **하나의 객체를 공유** (기본 설정)

•**프로토타입(prototype)**: 빈을 요청할 때마다 **새로운 객체를 생성 (생성후 관리하지 않음. 생성 반환만함 그리고 빈을 꺼낼때마다 새로운 객체 생성)**

•R**equest 스코프**: HTTP 요청이 발생할 때마다 **새로운 객체를 생성**

•**Session 스코프**: 사용자 세션마다 새로운 객체를 생성

---

### 스프링 웹 스코프

스프링에서 빈은 스프링 IOC 컨테이너에 의해 관리

빈의 생성 : 컨테이너 생성

Scope - Singleton Scope은 Scope 관리 방식에 따라 컨테이너가 종료 (ac.close) 가 되면 빈 소멸 

이런것 처럼 빈이 언제 생성되고 언제 소멸되는지에 대한 범위를 스코프 

프로토타입 스코프는 호출할때마다 빈을 생성하고 생성하면 관리하지않아서 소멸 매서드가 호출되지않고 출력되지않는 것.

ㅁ

웹 스코프(Web Scope: **Spring에서 웹 환경에서 사용되는 빈(Bean)의 생명주기**를 정의

즉, 빈이 **언제 생성되고, 언제 소멸되는지**를 결정하는 것이 스코프(Scope)이며, 웹 환경에서 사용하는 스코프를 웹 스코프(Web Scope) 라고 함.

| **스코프** | **생명주기 (Lifecycle)** | **특징** |
| --- | --- | --- |
| request | HTTP 요청이 들어올 때마다 새로운 빈이 생성되고 응답 후 소멸됨
(요청이 들어올때마다 빈을 생성하는 Prototype은 빈 소멸은 컨테이너가 관리하지않는데 
이 Request 스코프는 새로운 빈이 생성되고 응답 한뒤 Request 요청이 끝나면 자동으로 제거) | 각각의 HTTP 요청에 대해 독립적인 인스턴스가 필요한 경우 |
| session | HTTP 세션이 유지되는 동안 동일한 빈이 유지됨 | 사용자별로 독립적인 상태 정보를 저장해야 하는 경우 |
| application | 서블릿 컨텍스트(ServletContext)의 생명주기와 동일함 | 전체 애플리케이션에서 공통으로 사용할 데이터를 공유하는 경우 |
| websocket | 웹소켓(WebSocket) 연결이 지속되는 동안 빈이 유지됨 | 실시간 양방향 통신에서 상태를 유지해야 하는 경우 |

---

### 스프링 웹 스코프 - 프록시

1. Request Scope:

• HTTP 요청마다 새로운 객체가 생성됨

• 각 HTTP 요청은 자신만의 MyLogger 인스턴스를 가짐

• 요청이 끝나면 해당 인스턴스는 소멸됨

• Request Scope 객체는 각 요청마다 독립된 상태를 유지하며, 다른 요청과 상태를 공유하지 않음

2. Singleton Scope:

• 하나의 객체만 존재하며 애플리케이션 종료 시까지 유지됨

• 애플리케이션 전체에서 하나의 인스턴스를 공유하여 사용

• 싱글톤 빈은 애플리케이션 전역에서 사용되며, 종료 시까지 메모리에 존재

3. 프록시 객체 (가짜 대리자):

• 프록시 객체는 실제 객체인 MyLogger의 대리자 역할을 수행

• 클라이언트의 MyLogger 호출 시, 프록시 객체가 중간에서 요청을 처리

• 프록시 객체는 실제 객체에 대한 위임 역할을 담당

4. 왜 프록시 객체가 필요한가?

• 싱글톤 빈은 애플리케이션에서 단 하나의 인스턴스만 존재

• Request Scope 객체를 싱글톤 빈에 직접 주입하면, 요청별로 새로운 객체가 필요한데 싱글톤은 하나의 객체만 유지하므로 상태 공유나 잘못된 객체 사용 위험이 있음

• 프록시 객체를 활용하면 싱글톤 빈에서도 요청마다 새로운 Request Scope 객체를 안전하게 사용 가능

• 이를 통해 Request Scope 객체를 매 요청마다 독립적으로 생성하고, 싱글톤 빈에서도 안전하게 상태를 관리할 수 있음

5. 프록시 객체 동작 원리:

• 프록시 객체는 CGLIB 라이브러리나 JDK 동적 프록시를 통해 MyLogger 객체를 상속하거나 인터페이스를 구현하여 생성

• 프록시 객체 호출 시 실제 MyLogger 객체로 위임하고 Request Scope 객체를 요청

• 결과적으로 Request Scope 객체는 매 요청마다 독립적인 새 객체로 생성됨